/**
 * @file Publish script for Chrome Extensions. Uploads a pre-built ZIP file to the Chrome Web Store
 * using OAuth 2.0 credentials. Performs the following actions:
 *
 * 1. Loads manifest.json to determine the ZIP file name based on extension name and version
 * 2. Verifies the existence of the ZIP file generated by build.js
 * 3. Checks for required Chrome Web Store credentials in the environment
 * 4. Fetches an OAuth 2.0 access token if credentials are available
 * 5. Uploads the ZIP file to the Chrome Web Store if credentials are valid
 * 6. Logs detailed status updates and results
 *
 * Prerequisites:
 * - A ZIP file must exist from a prior run of build.js
 * - The extension must be published at least once to obtain a valid extension ID
 * - To enable auto-publishing, create a `.env` file in the project root with:
 *   - `CLIENT_ID`: OAuth 2.0 Client ID from Google Cloud Console (https://console.cloud.google.com/apis/credentials)
 *     - Use `Desktop App` as the application type
 *   - `CLIENT_SECRET`: OAuth 2.0 Client Secret from Google Cloud Console (https://console.cloud.google.com/apis/credentials)
 *   - `REFRESH_TOKEN`: OAuth 2.0 Refresh Token from OAuth 2.0 Playground (https://developers.google.com/oauthplayground)
 *     - Use `https://www.googleapis.com/auth/chromewebstore` as the scope
 *   - `EXTENSION_ID`: Chrome Extension ID from Chrome Web Store Developer Dashboard (https://chrome.google.com/webstore/developer/dashboard)
 * - If `.env` is missing or incomplete, the script logs a warning and prepares for manual upload
 *
 * @module PublishScript
 * @requires fs
 * @requires path
 * @requires dotenv
 */

const fs = require("fs");
const path = require("path");
require("dotenv").config();

const RED = "\x1b[1;31m";
const GREEN = "\x1b[1;32m";
const RESET = "\x1b[0m";

function red(text) {
    return `${RED}${text}${RESET}`;
}

function green(text) {
    return `${GREEN}${text}${RESET}`;
}

/**
 * Fetches an access token for Chrome Web Store API using OAuth 2.0 credentials.
 * @returns {Promise<string>} Access token
 */
async function getAccessToken() {
    const { CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN } = process.env;
    const response = await fetch("https://oauth2.googleapis.com/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
            client_id: CLIENT_ID,
            client_secret: CLIENT_SECRET,
            refresh_token: REFRESH_TOKEN,
            grant_type: "refresh_token",
        }),
    });
    const data = await response.json();
    if (!response.ok) throw new Error(data.error_description || "Failed to get access token");
    return data.access_token;
}

/**
 * Uploads the ZIP file to the Chrome Web Store.
 * @param {string} zipFilePath - Path to the ZIP file
 * @param {string} extensionId - Chrome Extension ID
 */
async function uploadToChromeWebStore(zipFilePath, extensionId) {
    const accessToken = await getAccessToken();
    const apiUrl = `https://www.googleapis.com/upload/chromewebstore/v1.1/items/${extensionId}`;
    const headers = {
        Authorization: `Bearer ${accessToken}`,
        "x-goog-api-version": "2",
        "Content-Type": "application/zip",
    };
    const response = await fetch(apiUrl, {
        method: "PUT",
        headers,
        body: fs.readFileSync(zipFilePath),
    });
    const result = await response.json();
    if (response.ok) {
        console.log(`✅ Successfully uploaded ${green(path.basename(zipFilePath))} to Chrome Web Store:`, result);
    } else {
        throw new Error(`Upload failed: ${JSON.stringify(result)}`);
    }
}

/**
 * Checks if Chrome Web Store credentials are available.
 * @returns {boolean} True if all required env vars are set
 */
function hasChromeWebStoreCredentials() {
    return process.env.CLIENT_ID && process.env.CLIENT_SECRET && process.env.REFRESH_TOKEN && process.env.EXTENSION_ID;
}

/**
 * Main publish script orchestrator.
 */
async function main() {
    try {
        // Load manifest.json to determine the ZIP file
        const manifestPath = path.join(__dirname, "static", "manifest.json");
        if (!fs.existsSync(manifestPath)) {
            throw new Error(`Manifest file ${green("manifest.json")} not found`);
        }
        const manifestJson = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
        const packageName = manifestJson.name.toLowerCase().replace(/\s+/g, "-");
        const version = manifestJson.version;
        const formattedVersion = `v${version.replace(/\./g, "-")}`;
        const zipFileName = `${packageName}-${formattedVersion}.zip`;
        const zipFilePath = path.join(__dirname, zipFileName);

        // Check if the ZIP file exists
        if (!fs.existsSync(zipFilePath)) {
            throw new Error(`ZIP file ${green(zipFileName)} not found. Run build.js first.`);
        }

        // Upload if credentials are available
        if (hasChromeWebStoreCredentials()) {
            await uploadToChromeWebStore(zipFilePath, process.env.EXTENSION_ID);
        } else {
            console.log(
                `⚠️  Chrome Web Store credentials not found. ${green(zipFileName)} is ready for manual upload.`
            );
        }
    } catch (error) {
        console.error(red(`❌ Error: ${error.message}`));
        process.exit(1);
    }
}

main();
